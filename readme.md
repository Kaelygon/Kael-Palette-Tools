<img src="https://raw.githubusercontent.com/Kaelygon/Kael-Palette-Tools/refs/heads/main/demoImages/Michelangelo_David_steinberg.png" alt="Steinberg example" width="180"/>
<img src="https://raw.githubusercontent.com/Kaelygon/Kael-Palette-Tools/refs/heads/main/demoImages/LPlumocrista_bayer_example.png" alt="Bayer example" width="256"/>
<img src="https://raw.githubusercontent.com/Kaelygon/Kael-Palette-Tools/refs/heads/main/demoImages/KaelygonLogo25_palettize16_example.png" alt="Palettize all 12 colors using pal16" width="256"/>

## Multi-license
The python scripts, palettes in "./palettes" are released into the public domain under the license [CC0 1.0 Universal (Kaelygon 2025)](https://creativecommons.org/public-domain/cc0/).

To avoid misattribution in subsequent releases, you must either change or remove the original name in the material licensed under CC0. I am not responsible for any derived works.

### Other images
The image files in "./demoImages" have their own respective licenses. See "./demoImages/license.txt"

## What does this try to solve?
I wanted to find peceptually uniform palette, with exactly N colors.  
Hence I created **palette_generator.py**, which generates N random points and spreads them using physics simulation constrained to OKLab gamut.

Then I wanted to palettize images limited to these colors, but I found ffmpeg insufficient.  
Hence I created **palettize_image.py**  
Here's some issues that I faced using ffmpeg as palettizer:
- ffmpeg collapses similar colors: In pixel art you want to preserve detail, even if it means using a wrong color. Ffmpeg naively chooses nearest color so detail is lost. That's why *--dither=none* has option *--max-error*, which allows you to set a range that unused palette colors can replace similar colors.
- ffmpeg bayer dither is unsuitable for irregular palettes: I wanted the "bayer-look" but ffmpeg is optimized for 256 color palettes in RGB, so I came up with the current ridiculous solution. It is rather complex, but still much faster than steinberg and visually pleasing.

~ Kaelygon

## Palette tools

### palettize_image.py
*Palettize and dither using arbitrary palette*
```
python palettize_image.py [-h] [-i INPUT] [-p PALETTE] [-o OUTPUT] [-a ALPHA_COUNT] [-e MAX_ERROR] [-m MERGE_RADIUS] [-d DITHER] [-b BAYER_SIZE] [-B BAYER_WEIGHT] [-D DEMO]
```
The only proper tool.

Minimal syntax
```
python palettize_image.py -i input.png -p palette.png
```
will generate p_input.png in the same folder as input.png

Options:
```
-D, --demo          (bool ) Generate demo images
-i, --input         (str  ) Path to input .png
-p, --palette       (str  ) Path to palette .png
-o, --output        (str  ) Path to output .png

-a, --alpha-count   (int  ) How many alpha levels
-d, --dither        (str  ) Dither type. Options: none, bayer, steinberg
-b, --bayer-size    (int  ) Bayer matrix size. <1 is invalid. Only powers of 2s are proper Bayer matrices. Anything beyond 16 makes little difference 
-e, --max-error     (float) Higher will allow farther colros to replace unique colors. 1.0-1.5 is roughly 12 nearest neighbors in uniform palette. Preserves detail but causes banding at high levels. 1.0-2.0 is good for pixel art.
-m, --merge-radius  (float) Quantize before palettizing. 1.0 will result roughly in same number of colors as palette, but loses information. Reduces unique colors, so 0.01 to 0.2 is good value for high depth images. May improve performance and palettization.
-B, --bayer-weight  (float) Scale threshold by 
   0.0 palette channel gaps 
   0.0-1.0 palette gap norm * quantized error 
   1.0-2.0 bias palette gap norm
   May over-dither but results in smoother gradients and better colors
```

### palette_generator.py
*Generate uniform palette in OKLab gamut*
```
python palette_generator.py
```
Preset must be modified in the python script to generate custom palette.
Generates "./output/cloudHistogram.py" which contains massive array of palette point cloud relaxation snapshots generated by ParticleSim.py.


### ok_plot_histogram.py
*Plot 3D histogram generated by palette_generator.py*
```
python ok_plot_histogram.py
```
Yank but it kinda works for debugging the results
