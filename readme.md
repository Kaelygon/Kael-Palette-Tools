[comment]: <> (Remember to change '/testing/' to '/main/' when mergin to main)  
<img src="https://raw.githubusercontent.com/Kaelygon/Kael-Palette-Tools/refs/heads/testing/demoImages/Michelangelo_David_steinberg.png" alt="Steinberg example" width="180"/>  
<img src="https://raw.githubusercontent.com/Kaelygon/Kael-Palette-Tools/refs/heads/testing/demoImages/LPlumocrista_dither_variants.png" alt="Bayer example" width="256"/>  
<img src="https://raw.githubusercontent.com/Kaelygon/Kael-Palette-Tools/refs/heads/testing/demoImages/KaelygonLogo25_palettize16_example.png" alt="Palettize all 12 colors using pal16" width="256"/>  

## Multi-license
The python scripts, palettes in "./palettes" are released into the public domain under the license [CC0 1.0 Universal (Kaelygon 2025)](https://creativecommons.org/public-domain/cc0/).

To avoid misattribution in subsequent releases, you must either change or remove the original name in the material licensed under CC0. I am not responsible for any derived works.

### Other images
The image files in "./demoImages" have their own respective licenses. See "./demoImages/license.txt"

## What does this try to solve?
I wanted to find perceptually uniform palette, with exactly N colors.  
Hence I created **palette_generator.py**, which generates N random points and spreads them using physics simulation constrained to OKLab gamut.

Then I wanted to palettize images limited to these colors, but I found ffmpeg insufficient.  
Hence I created **palettize_image.py**  
Here's some issues that I faced using ffmpeg as palettizer:
- ffmpeg collapses similar colors: In pixel art you want to preserve detail, even if it means using a wrong color. Ffmpeg naively chooses nearest color so detail is lost. That's why *--dither=none* has option *--max-error*, which allows you to set a range that unused palette colors can replace similar colors.
- ffmpeg bayer dither is unsuitable for irregular palettes: I wanted the "bayer-look" but ffmpeg is optimized for 256 color palettes in RGB, so I came up with the current ridiculous solution. It is rather complex, but still much faster than steinberg and visually pleasing.

~ Kaelygon

## Palette tools

### palettize_image.py
*Palettize and dither using arbitrary palette*
```
python palettize_image.py [-h] [-i INPUT] [-p PALETTE] [-o OUTPUT] [-a ALPHA_COUNT] [-e MAX_ERROR] [-mr MERGE_RADIUS] [-d DITHER] [-ms MASK_SIZE] [-dw MASK_WEIGHT] [-D DEMO]
```
The only proper tool.

Minimal syntax
```
python palettize_image.py -i input.png -p palette.png
```
will generate p_input.png in the same folder as input.png

Options:
```
-D, --demo          (bool ) Generate demo images
-h, --help          (None ) show this help message and exit
-i, --input         (str  ) Path to input .png
-p, --palette       (str  ) Path to palette .png
-o, --output        (str  ) Path to output .png

-a, --alpha-count   (int  ) How many alpha levels
-e, --max-error     (float) Higher will allow farther colros to replace unique colors. Preserves detail but causes banding at high levels. 1.0-2.0 is good for pixel art.
-mr, --merge-radius (float) Quantize before palettizing. Reduces unique colors, 0.01 to 0.2 are good values for high depth images.

-d, --dither        (str  ) Dither type. Options: none, bayer, steinberg
-ms, --mask-size    (int  ) Dither mask tile size for dither=(bayer, blue) 
-dw, --mask-weight  (float) Dither strength for dither=(none, bayer). >1.0 May over-dither but results in smoother gradients and better colors
```

### palette_generator.py
*Generate uniform palette in OKLab gamut*
```
python palette_generator.py
```
Preset must be modified in the python script to generate custom palette.
Generates "./output/cloudHistogram.npy" which contains massive array of palette point cloud relaxation snapshots generated by ParticleSim.py.


### ok_plot_histogram.py
*Plot 3D histogram generated by palette_generator.py*
```
python ok_plot_histogram.py
```
Yank but it kinda works for debugging the results
